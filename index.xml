<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lhw_itguy</title>
    <link>https://ippoeyeslhw.github.io/index.xml</link>
    <description>Recent content on lhw_itguy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 24 Jan 2017 23:13:02 +0900</lastBuildDate>
    <atom:link href="https://ippoeyeslhw.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go signal</title>
      <link>https://ippoeyeslhw.github.io/post/go-signal/</link>
      <pubDate>Tue, 24 Jan 2017 23:13:02 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/go-signal/</guid>
      <description>&lt;p&gt;고언어에서 os signal 을 콘트롤 하는 방법을 찾아보았다.&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;os/signal&amp;quot;
    &amp;quot;syscall&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {

    // signal 채널을 만든다.
    signal_chan := make(chan os.Signal, 2)
    signal.Notify(signal_chan, syscall.SIGINT) // ctrl+c

    // loop
    isDone := false
    for isDone != true {
        // signal handler
        select {
        case sig := &amp;lt;-signal_chan:
            fmt.Println(&amp;quot;signal!! &amp;quot;, sig)
            isDone = true
        default:
            isDone = false
        }
        time.Sleep(1)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;채널을 통해서 signal을 전달하게 된다.
버퍼드채널과 select 를 이용하여 non-blocking 으로 구현하였다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpgo lib</title>
      <link>https://ippoeyeslhw.github.io/post/cpgo-lib/</link>
      <pubDate>Tue, 24 Jan 2017 22:20:08 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/cpgo-lib/</guid>
      <description>

&lt;p&gt;저번에 올렸던 &lt;a href=&#34;https://ippoeyeslhw.github.io/post/golang-with-cybosplus&#34;&gt;포스트golang-with-cybosplus&lt;/a&gt; 에서 사이보스플러스와 Go 언어를 연동하는 법을 살폈다. 이를 사용하여 Wrapper 라이브러를 작성하여 Github에 &lt;a href=&#34;https://github.com/ippoeyeslhw/cpgo&#34;&gt;https://github.com/ippoeyeslhw/cpgo&lt;/a&gt; 프로젝트를 올렸다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;파이썬과-비교&#34;&gt;파이썬과 비교&lt;/h2&gt;

&lt;p&gt;파이썬에서 구현하는 방법을 참고하여 유사하게 만들려고 노력했다.&lt;/p&gt;

&lt;h2 id=&#34;객체생성&#34;&gt;객체생성&lt;/h2&gt;

&lt;p&gt;객체를 생성할때는 CpClass 객체를 만든뒤 Create를 호출한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stkmst := &amp;amp;cpgo.CpClass{}
stkmst.Create(&amp;quot;CpDib.StockMst&amp;quot;)
defer stkmst.Release()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이에 대응되는 파이썬 코드는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stkmst = win32com.client.Dispatch(&amp;quot;dscbo1.StockMst&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;파이썬과는 다르게 COM을 다루고 있다는 느낌을 줄이려고 했다.&lt;/p&gt;

&lt;h2 id=&#34;이벤트&#34;&gt;이벤트&lt;/h2&gt;

&lt;p&gt;이벤트를 처리하기위해 이벤트 핸들러는 Receiver 인터페이스를 구현하도록 하였다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Receiver interface {
    Received(*CpClass)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 인터페이스를 구현하는 구조체를 아래와 같이 생성한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type RqTestStruct struct {
}

func (t *RqTestStruct) Received(c *CpClass) {
    // pass
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이에 대응되는 파이썬의 이벤트 핸들러는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CpSubPubEventHandler:
    def __init__(self):
        pass
    def OnReceived(self):
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 핸들러를 객체에 연동하려면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;evnt := &amp;amp;RqTestStruct{}
cpobj.BindEvent(evnt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이에 대응되는 파이썬 코드는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;win32com.client.WithEvents(cpobj, CpSubPubEventHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpgo는 객체를 만들어서 바인딩하는 것이고 파이썬은 클래스를 등록하는 것이다.&lt;/p&gt;

&lt;h2 id=&#34;이벤트-수신대기&#34;&gt;이벤트 수신대기&lt;/h2&gt;

&lt;p&gt;go-ole패키지에 이상하게도 PeekMessage 메서드가 없었다. 따라서 이를 구현해준뒤에 pythoncom 에 있는 PumpWaitingMessages 함수를 유사하게 구현하였다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for  {
    cpgo.PumpWaitingMessages()
    time.Sleep(1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;파이썬과 매우 유사하다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while True:
    pythoncom.PumpWaitingMessages()
    time.sleep(0.001)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;이벤트-수신의-문제&#34;&gt;이벤트 수신의 문제&lt;/h2&gt;

&lt;p&gt;주식 실시간 호가를 받아오기 위해 CpDib.StockJpBid를 사용하여 실시간으로 호가를 받아오고 있었는데 특이한 현상을 발견했다.&lt;/p&gt;

&lt;p&gt;개발했던 PC에서는 잘 되었지만 다른PC에서 실시간 이벤트가 잘 수신되지 않았다.&lt;/p&gt;

&lt;p&gt;실시간으로 잘 받아오고 있다가 어느순간에 이벤트 수신을 하지 못하는 현상이였다. 그러다가 갑자기 또 수신을 쏟아지듯 받다가 못받다가 반복을 하였다. COM 서버 디버깅이 힘든 상황이라 원인 찾기가 힘들었다.&lt;/p&gt;

&lt;h2 id=&#34;go-scheduler&#34;&gt;Go-Scheduler&lt;/h2&gt;

&lt;p&gt;원인으로 OS thread가 중간에 교체가 되는것이 아닌가 하여 검색을 해보니
golang 에서는 go scheduler 가 있어서 M개의 OS-threads 와 N개의 goroutines
을 적당하게 관리해준다고 한다.&lt;/p&gt;

&lt;p&gt;COM 에서는 이벤트를 맺은 윈도우 스레드에만 메시지를 전달하는데 만일
go scheduler 가 중간에 os-thread 를 바꿔버린다면 이벤트 수신이 중간에 끊기게
되는 것이다.&lt;/p&gt;

&lt;p&gt;따라서 이를 해결하기 위해 CreateThread 메서드를 추가했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Background func(uintptr) uintptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Background 인터페이스는 uintptr 을 인자로 받아 uintptr을 리턴한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func CreateThread(fnc Background, arg1 uintptr) (ret int32, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go-scheduler 를 통하지 않고 이렇게 직접 스레드를 생성하여 중간에 교체가
되지 않도록 하여 이벤트를 끊김없이 받을수 있도록 한다.&lt;/p&gt;

&lt;p&gt;다만 스레드함수는 이상하게 dll 로드하여 메서드를 따와도 수행이 되지 않았다.&lt;/p&gt;

&lt;p&gt;구글링 결과..  &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt; 를 해야만 동작한다고 한다. 좀 황당하지만
어떠한 C코드도 없이 단지 import 만 하면 된다.  이렇게 되면 순수 go언어
컴파일러로 바이나리를 만드는것이 아니고 gcc가 필요하게 된다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang with cybosplus</title>
      <link>https://ippoeyeslhw.github.io/post/golang-with-cybosplus/</link>
      <pubDate>Tue, 24 Jan 2017 22:03:21 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/golang-with-cybosplus/</guid>
      <description>

&lt;p&gt;증권 API 중에 사이보스플러스가 사용하기 쉽다. 하지만 쉽다는 사이보스플러스조차도 COM에 관련된 지식이 있어야 프로그래밍이 가능하다.&lt;/p&gt;

&lt;p&gt;GO언어로 만든 Github의 프로젝트중에 go-ole 라는 것을 찾았다. 이를 찾고보니 사이보스플러스와 연동이 가능할것 같아서 연동해보기로 하고 여러 시행착오 끝에 어떻게 연동을 하였는지 그 과정을 적어보고자 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;환경&#34;&gt;환경&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;윈도우 운영체제&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사이보스플러스 설치&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go언어 설치 (주의!: 32비트 버젼이어야함)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;빌드 및 실행 (주의!: 관리자권한으로 실행하여야함)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git 설치 (go get 명령으로 github의 프로젝트를 받아오기 위해)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;go-ole 패키지 설치&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Oleviewer 혹은 tih 파일 (Optional)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아마도 다른 언어들과 연동할때도 발생하는 문제일 텐데 64비트 바이너리로 언어를 설치하면 사이보스플러스와 연동이 되지 않는다. 마찬가지 현상을 요번에 발견하여 32비트 버젼으로 재설치하였다.&lt;/p&gt;

&lt;p&gt;go get 명령을 사용해서 github의 프로젝트를 가져오려고 하면 git이 필요하다.&lt;/p&gt;

&lt;p&gt;Oleviewer 는 CLSID, IID 를 보기위한 것이다. 구하기 힘들다면 사이보스플러스 개발예제에서 VC 예제에 항시 .tih 파일이 있을것이다. 이를 활용해도 된다.&lt;/p&gt;

&lt;h2 id=&#34;기본연동순서&#34;&gt;기본연동순서&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;사용하고자하는 사이보스플러스 객체를 만들기 위해 CLSID를 알아낸다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLSID와 IID_IUnknown 정보를 이용하여 IUnknown 객체 생성한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IUnknown 객체에 QueryInterface로 IID_IDispatch 정보를 사용하여 객체를 얻어낸다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IDispatch객체를 사용하여 원하는 메스드를 Call 하거나 속성을 사용한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;COM이란 것을 써본적이 없으면 무슨소리인가 할 것이다. 일단 만만한 CpUtil쪽 을 연동하면서 소스로 확인해본다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    ole &amp;quot;github.com/go-ole/go-ole&amp;quot;
    &amp;quot;github.com/go-ole/go-ole/oleutil&amp;quot;
)

func main() {
    // ole inti
    ole.CoInitialize(0)
    defer ole.CoUninitialize()

    // 1. clsid 구함
    stkcod_clsid, err := ole.CLSIDFromString(&amp;quot;CPUTIL.CpStockCode&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(stkcod_clsid)

    // 2. unknown 객체 생성
    unknown, err := ole.CreateInstance(stkcod_clsid, ole.IID_IUnknown)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(unknown)

    // 3. Get obj
    cpstkcod, err := unknown.QueryInterface(ole.IID_IDispatch)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(cpstkcod)

    // 4. call method       
    r, err := oleutil.CallMethod(cpstkcod, &amp;quot;CodeToName&amp;quot;, &amp;quot;A000270&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r.Value())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행결과는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{2297F381-FFB1-45C6-AA80-4C6913F45E91}
&amp;amp;{0x5f5734}
&amp;amp;{{0x5f5734}}
기아차
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oleviewer 를 사용하여 CpStockCode coclass 를 살펴보면 아래와 같이 나온다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  uuid(2297F381-FFB1-45C6-AA80-4C6913F45E91),
  helpstring(&amp;quot;CpStockCode Class&amp;quot;)
]
coclass CpStockCode {
    [default] interface ICpStockCode;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서의 uuid를 보면 바로 첫번쨰로 출력된 그 값이다. 결국 사이보스플러스 도움말에 나오는 클래스들.. 즉 CpCybos, CpStockCode, StockMst, StockCur, …. 이런 놈들은 coclass라고 부르며 각각 16bytes 의 GUID를 가지고 있다.&lt;/p&gt;

&lt;p&gt;요 CLSID를 일단 구한뒤에 일단 객체로 생성한다. 이떄 가장 기본적인 IID_IUnknown 인터페이스로 생성한다. 그리고 QueryInterface 메서드와 IID_IDispatch 를 사용하여 실제로 사용할 객체를 얻어낸다.&lt;/p&gt;

&lt;p&gt;이는 COM의 핵심이며 자세한 내용을 알아보려면 아래 링크를 추천한다. C언어에 대한 지식이 있어야한다. COM in plain C&lt;/p&gt;

&lt;h2 id=&#34;blockrequest&#34;&gt;BlockRequest&lt;/h2&gt;

&lt;p&gt;BlockRequest는 동기적으로 네트워크 요청을 하고 응답을 받는것이다. 즉 요청을 하면 실행이 멈추었다가 응답을 받아야 그 다음으로 진행이 된다. 이는 개념적으로 위 예제와 거의 유사한 방식으로 처리할수 있다.&lt;/p&gt;

&lt;p&gt;다만 위 예제는 함수의 리턴값을 받아온 것이고 block-request 는 네트워크 요청으로 응답을 받아온것이라는것이 큰 차이이다. 네트워크로 요청하였으니 결과값은 GetHeaderValue, GetDataValue 와 같은 함수를 호출하여 얻어와야한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    ole &amp;quot;github.com/go-ole/go-ole&amp;quot;
    &amp;quot;github.com/go-ole/go-ole/oleutil&amp;quot;
)

func main() {
    // ole inti
    ole.CoInitialize(0)
    defer ole.CoUninitialize()

    // clsid 구함
    stkmst_clsid, err := ole.CLSIDFromString(&amp;quot;DSCBO1.StockMst&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(stkmst_clsid)

    // unknown
    unknown, err := ole.CreateInstance(stkmst_clsid, ole.IID_IUnknown)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(unknown)

    // get obj
    cpstkmst, err := unknown.QueryInterface(ole.IID_IDispatch)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(cpstkmst)

    // call method

    r, err := oleutil.CallMethod(cpstkmst, &amp;quot;SetInputValue&amp;quot;,0, &amp;quot;A000270&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r)

    r, err = oleutil.CallMethod(cpstkmst, &amp;quot;BlockRequest&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r)

    r, err = oleutil.CallMethod(cpstkmst, &amp;quot;GetHeaderValue&amp;quot;, 1)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r.Value())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행결과는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{9FF543E2-FB11-11D3-8224-00105A7C4F8C}
&amp;amp;{0x324c1134}
&amp;amp;{{0x324c1134}}
&amp;amp;{VT_EMPTY 0 0 0 0}
&amp;amp;{VT_I2 0 0 0 0}
기아차
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;event-handler&#34;&gt;Event Handler&lt;/h2&gt;

&lt;p&gt;BlockRequest 는 네트워크 요청이후 실행흐름이 멈춘다고 설명했다. 이는 컴퓨터자원을 엄청나게 낭비하는 것이다. 이를 방지하기 위해 비동기적 실행흐름을 생각해볼수 있다. 비동기적 처리흐름은 일단 요청을 하고 응답이 왔을때 처리할 함수를 알려준다(콜백) 실제 응답이 오면 콜백을 실행한다.&lt;/p&gt;

&lt;p&gt;Request 함수로 요청을 날렸을때 이런 방식대로 수행이된다. 그리고 실시간으로 데이터가 전달되는 Sub/Pub 방식의 통신도 이렇게 이벤트 핸들링을 해야 처리가 가능하다.&lt;/p&gt;

&lt;p&gt;그럼 COM에서는 이벤트를 어떻게 처리할까? 결론부터 말하자면 COM서버측의 IConnectionPoint와 이를 관리하는 IConnectionPointContainer 그리고 클라이언트의 sink 인터페이스 구현으로 처리한다. COM서버는 사이보스플러스이고 우리가 작성하는 프로그램이 클라이언트이다.&lt;/p&gt;

&lt;p&gt;go-ole 프로젝트에 보면 example 폴더에 winsock예제가 있다. 이를 응용하여 사이보스플러스에 적용시켜보기로 한다.&lt;/p&gt;

&lt;p&gt;Oleviewer로 DSCBO1Lib의 dispinterface _IDibEvents 를 보면 아래와 같이 나온다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  uuid(B8944520-09C3-11D4-8232-00105A7C4F8C),
  helpstring(&amp;quot;_IDibEvents Interface&amp;quot;)
]
dispinterface _IDibEvents {
    properties:
    methods:
        [id(0x00000001), helpstring(&amp;quot;method Received&amp;quot;)]
        void Received();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;요 IID를 사용하여 ConnectionPoint를 지정해줄것이다.&lt;/p&gt;

&lt;p&gt;위 winsock예제와 같이 가상함수 테이블을 구현하는 구조체를 선언해준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type CpReceiveEvent struct {
    lpVtbl *CpReceivedEvntVtbl
    ref    int32
    host   *ole.IDispatch
}
type CpReceivedEvntVtbl struct {
    // IUnknown
    pQueryInterface   uintptr
    pAddRef           uintptr
    pRelease          uintptr
    // IDispatch
    pGetTypeInfoCount uintptr
    pGetTypeInfo      uintptr
    pGetIDsOfNames    uintptr
    pInvoke           uintptr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;void Received 함수는 포인터로 지정하지 않는다. host는 요 이벤트를 연결할 사이보스플러스 객체이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func QueryInterface(this *ole.IUnknown, iid *ole.GUID, punk **ole.IUnknown) uint32 {
    s, _ := ole.StringFromCLSID(iid)
    *punk = nil
    if ole.IsEqualGUID(iid, ole.IID_IUnknown) ||
        ole.IsEqualGUID(iid, ole.IID_IDispatch) {
        AddRef(this)
        *punk = this
        return ole.S_OK
    }       
    if s == &amp;quot;{B8944520-09C3-11D4-8232-00105A7C4F8C}&amp;quot; {
        AddRef(this)
        *punk = this
        return ole.S_OK
    }

    return ole.E_NOINTERFACE
}

func AddRef(this *ole.IUnknown) int32 {
    pthis := (*CpReceiveEvent)(unsafe.Pointer(this))
    pthis.ref++
    return pthis.ref
}

func Release(this *ole.IUnknown) int32 {
    pthis := (*CpReceiveEvent)(unsafe.Pointer(this))
    pthis.ref--
    return pthis.ref
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IUnknown 인테페이스를 구현한다. QueryInterface함수에서 _IDibEvents의 IID를 받았을때 자기자신의 포인터를 아웃풋변수에 넣도록 해준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func GetIDsOfNames(this *ole.IUnknown, iid *ole.GUID, wnames []*uint16, namelen int, lcid int, pdisp []int32) uintptr {
    for n := 0; n &amp;lt; namelen; n++ {
        pdisp[n] = int32(n)
    }
    return uintptr(ole.S_OK)
}
func GetTypeInfoCount(this *ole.IUnknown,pcount *int) uint32 {
    if pcount != nil {
        *pcount = 0
    }
    return ole.S_OK
}

func GetTypeInfo(this *ole.IUnknown, namelen int, lcid int) uint32 {
    return ole.E_NOTIMPL
}
func Invoke(this *ole.IDispatch, dispid int, riid *ole.GUID, lcid int, flags int16, dispparams *ole.DISPPARAMS, result *ole.VARIANT, pexcepinfo *ole.EXCEPINFO, nerr *uint) uintptr {
    if dispid == 1 {
        // call Received
    }
    return ole.E_NOTIMPL
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IDispatch 인터페이스를 구현한다. COM서버와 클라이언트간 약속된 인터페이스는 여기까지이다. 여기서 dispinterface 였던 _IDibEvents 인터페이스는 Received 함수만 존재했었지만 실제로 구현하지 않고 Invoke 함수가 dispid 로 함수의 ID 값을 넘겨받아 호출된다. 이는 GetIDsOfNames가 구현됨으로서 가능하다. _IDibEvents는 간단하게도 Received 함수 하나뿐이라 ID값이 1로 전달될 것이다. 이런 구조는 실제로 여러 언어나 개발환경에서는 자동화되어 생성이 되지만 GO언어에서는 딱히 지원되는것이 아니므로 이렇게 일일히 구현이 되어야 한다.&lt;/p&gt;

&lt;p&gt;여기서 GetIDsOfNames 함수를 선언할때 문제점이 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dest:= (new (CpReceiveEvent))
dest.lpVtbl = (new (CpReceivedEvntVtbl))
dest.lpVtbl.pQueryInterface = syscall.NewCallback(QueryInterface)
dest.lpVtbl.pAddRef = syscall.NewCallback(AddRef)
dest.lpVtbl.pRelease = syscall.NewCallback(Release)
dest.lpVtbl.pGetTypeInfoCount = syscall.NewCallback(GetTypeInfoCount)
dest.lpVtbl.pGetTypeInfo = syscall.NewCallback(GetTypeInfo)
dest.lpVtbl.pGetIDsOfNames = syscall.NewCallback(GetIDsOfNames)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 syscall.NewCallback 을 사용하여 콜백함수를 지정을 하면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panic: compileCallback: input parameter size is wrong
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;라는 에러가 나올것이다. 이는 GetIDsOfNames 함수를 NewCallback 인자로 넘겨주었을때 발생하는데 해당 소스는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func compileCallback(fn eface, cleanstack bool) (code uintptr) {
if fn._type == nil || (fn._type.kind&amp;amp;kindMask) != kindFunc {
    panic(&amp;quot;compileCallback: not a function&amp;quot;)
}
ft := (*functype)(unsafe.Pointer(fn._type))
if len(ft.out) != 1 {
    panic(&amp;quot;compileCallback: function must have one output parameter&amp;quot;)
}
uintptrSize := unsafe.Sizeof(uintptr(0))
if ft.out[0].size != uintptrSize {
    panic(&amp;quot;compileCallback: output parameter size is wrong&amp;quot;)
}
argsize := uintptr(0)
for _, t := range ft.in {
    if t.size &amp;gt; uintptrSize {
        panic(&amp;quot;compileCallback: input parameter size is wrong&amp;quot;)
    }
    argsize += uintptrSize
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이상하다. 정확히는 모르겠지만 uintptrSize와 각각의 인풋파라미터의 타입을 비교하는 것처럼 보인다. 하지만 괴상하게도 되지 않는다. 이것때문에 한동안 막혀 진행이 되지 않다가 다음과 같은 소스를 찾고나서 해결하였다. &lt;a href=&#34;https://gist.github.com/mattn/794587&#34;&gt;https://gist.github.com/mattn/794587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;결국 GetIDsOfNames 함수는 아래와같이 만들어준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func GetIDsOfNames(args *uintptr) uint32 {
    p := (*[6]int32)(unsafe.Pointer(args))
    //this := (*ole.IDispatch)(unsafe.Pointer(uintptr(p[0])))
    //iid := (*ole.GUID)(unsafe.Pointer(uintptr(p[1])))
    wnames := *(*[]*uint16)(unsafe.Pointer(uintptr(p[2])))
    namelen := int(uintptr(p[3]))
    //lcid := int(uintptr(p[4]))
    pdisp := *(*[]int32)(unsafe.Pointer(uintptr(p[5])))
    for n := 0; n &amp;lt; namelen; n++ {
        s := ole.UTF16PtrToString(wnames[n])
        println(s)
        pdisp[n] = int32(n)
    }
    return ole.S_OK
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;oleutil에 있는 ConnectObject 함수도 결국은 GetIDsOfNames 함수를 가지고 NewCallback을 호출하는데 &lt;a href=&#34;https://github.com/go-ole/go-ole/blob/master/oleutil/connection.go&#34;&gt;https://github.com/go-ole/go-ole/blob/master/oleutil/connection.go&lt;/a&gt; 를 보면 이것도 마찬가지로 같은 에러가 난다. 따라서 oleutil을 활용할수가 없다.&lt;/p&gt;

&lt;p&gt;결국 IConnectionPoint를 직접 만들어줘야하는 번거로움이 생기게 된다. 이걸 사용하는 순서는 아래와 같다.&lt;/p&gt;

&lt;p&gt;사이보스플러스 객체에서 QueryInterface로 IID_IConnectionPointContainer 인터페이스를 요청하여 생성
FindConnectionPoint 함수에 _IDibEvents의 iid 를 이용하여 point 를 알아낸다.
해당 point의 Advise 함수 호출
아래와 같이 구현해보면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// get event iid
dibevnt_iid, err := ole.CLSIDFromString(&amp;quot;{B8944520-09C3-11D4-8232-00105A7C4F8C}&amp;quot;)
if  err != nil {
    fmt.Println(err)
    return 
}
fmt.Println(dibevnt_iid)

// 이벤트 객체 생성 및 IUnkown, IDispatch 구현  콜백등록
evnt:= (new (CpReceiveEvent))
evnt.lpVtbl = (new (CpReceivedEvntVtbl))
evnt.lpVtbl.pQueryInterface = syscall.NewCallback(QueryInterface)
evnt.lpVtbl.pAddRef = syscall.NewCallback(AddRef)
evnt.lpVtbl.pRelease = syscall.NewCallback(Release)
evnt.lpVtbl.pGetTypeInfoCount = syscall.NewCallback(GetTypeInfoCount)
evnt.lpVtbl.pGetTypeInfo = syscall.NewCallback(GetTypeInfo)
evnt.lpVtbl.pGetIDsOfNames = syscall.NewCallback(GetIDsOfNames)
evnt.lpVtbl.pInvoke = syscall.NewCallback(Invoke)
evnt.host = cpstkmst

// connectionpoint container
unknown_con, err := cpstkmst.QueryInterface(ole.IID_IConnectionPointContainer)
if err != nil {
    fmt.Println(err)
    return 
}

fmt.Println(unknown_con)

// get point
container := (*ole.IConnectionPointContainer)(unsafe.Pointer(unknown_con))
var point *ole.IConnectionPoint
err = container.FindConnectionPoint(dibevnt_iid, &amp;amp;point)
if err != nil {
    return
}
fmt.Println(point)

// Advise
cookie, err := point.Advise((*ole.IUnknown)(unsafe.Pointer(evnt)))
container.Release()
if err != nil {
    point.Release()
    fmt.Println(err)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Request 요청을 날리게 되면 응답을 받을때까지 대기를 하여야 한다. 이는 어느시점에 발생할지 모르기 떄문에 무한루프로 대기를 하도록 한다. 아래는 적당한 시점에 종료되도록 만든것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// wating infinite  
cnt := 0
var m ole.Msg
for evnt.ref != 0 {
    time.Sleep(10)
    ole.GetMessage(&amp;amp;m,0,0,0)
    ole.DispatchMessage(&amp;amp;m)
    if cnt &amp;gt; 1000 {
        break
    }
    cnt++
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제 콜백이 수행되는것은 Invoke 가 수행이 되며 여기에 메서드의 ID값을 넘겨주게 된다. _IDibEvents는 어차피 메서드가 Received 한개이므로 무조건 1일 것이다.&lt;/p&gt;

&lt;p&gt;적당히 Received를 꾸민뒤에 Invoke에서 호출된다고 가정하고 Received를 작성해보았다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Received(this *ole.IDispatch) {
    pthis := (*CpReceiveEvent)(unsafe.Pointer(this))
    r, err := oleutil.CallMethod(pthis.host, &amp;quot;GetHeaderValue&amp;quot;, 1)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r.Value())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행결과는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;call Received
기아차
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;전체소스&#34;&gt;전체소스&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    ole &amp;quot;github.com/go-ole/go-ole&amp;quot;
    &amp;quot;github.com/go-ole/go-ole/oleutil&amp;quot;
    &amp;quot;unsafe&amp;quot;
    &amp;quot;syscall&amp;quot;
    &amp;quot;time&amp;quot;
)

type CpReceiveEvent struct {
    lpVtbl *CpReceivedEvntVtbl
    ref    int32
    host   *ole.IDispatch
}
type CpReceivedEvntVtbl struct {
    // IUnknown
    pQueryInterface   uintptr
    pAddRef           uintptr
    pRelease          uintptr
    // IDispatch
    pGetTypeInfoCount uintptr
    pGetTypeInfo      uintptr
    pGetIDsOfNames    uintptr
    pInvoke           uintptr
}

func QueryInterface(this *ole.IUnknown, iid *ole.GUID, punk **ole.IUnknown) uint32 {
    s, _ := ole.StringFromCLSID(iid)
    *punk = nil
    if ole.IsEqualGUID(iid, ole.IID_IUnknown) ||
        ole.IsEqualGUID(iid, ole.IID_IDispatch) {
        AddRef(this)
        *punk = this
        return ole.S_OK
    }       
    if s == &amp;quot;{B8944520-09C3-11D4-8232-00105A7C4F8C}&amp;quot; {
        AddRef(this)
        *punk = this
        return ole.S_OK
    }

    return ole.E_NOINTERFACE
}

func AddRef(this *ole.IUnknown) int32 {
    pthis := (*CpReceiveEvent)(unsafe.Pointer(this))
    pthis.ref++
    return pthis.ref
}

func Release(this *ole.IUnknown) int32 {
    pthis := (*CpReceiveEvent)(unsafe.Pointer(this))
    pthis.ref--
    return pthis.ref
}
func GetIDsOfNames(args *uintptr) uint32 {
    fmt.Println(&amp;quot;gettypeinfo?&amp;quot;)
    p := (*[6]int32)(unsafe.Pointer(args))
    //this := (*ole.IDispatch)(unsafe.Pointer(uintptr(p[0])))
    //iid := (*ole.GUID)(unsafe.Pointer(uintptr(p[1])))
    wnames := *(*[]*uint16)(unsafe.Pointer(uintptr(p[2])))
    namelen := int(uintptr(p[3]))
    //lcid := int(uintptr(p[4]))
    pdisp := *(*[]int32)(unsafe.Pointer(uintptr(p[5])))
    for n := 0; n &amp;lt; namelen; n++ {
        s := ole.UTF16PtrToString(wnames[n])
        println(s)
        pdisp[n] = int32(n)
    }
    return ole.S_OK
}
func GetTypeInfoCount(this *ole.IUnknown,pcount *int) uint32 {
    if pcount != nil {
        *pcount = 0
    }
    return ole.S_OK
}

func GetTypeInfo(this *ole.IUnknown, namelen int, lcid int) uint32 {
    return ole.E_NOTIMPL
}
func Invoke(this *ole.IDispatch, dispid int, riid *ole.GUID, lcid int, flags int16, dispparams *ole.DISPPARAMS, result *ole.VARIANT, pexcepinfo *ole.EXCEPINFO, nerr *uint) uintptr {
    if dispid == 1 {
        // call Received
        fmt.Println(&amp;quot;call Received&amp;quot;)
        Received(this)
    }
    return ole.E_NOTIMPL
}

func Received(this *ole.IDispatch) {
    pthis := (*CpReceiveEvent)(unsafe.Pointer(this))
    r, err := oleutil.CallMethod(pthis.host, &amp;quot;GetHeaderValue&amp;quot;, 1)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r.Value())
}

func main() {
    // ole inti
    ole.CoInitialize(0)
    defer ole.CoUninitialize()

    // clsid 구함
    stkmst_clsid, err := ole.CLSIDFromString(&amp;quot;DSCBO1.StockMst&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(stkmst_clsid)

    // unknown
    unknown, err := ole.CreateInstance(stkmst_clsid, ole.IID_IUnknown)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(unknown)

    // get obj
    cpstkmst, err := unknown.QueryInterface(ole.IID_IDispatch)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(cpstkmst)

    // get event iid
    dibevnt_iid, err := ole.CLSIDFromString(&amp;quot;{B8944520-09C3-11D4-8232-00105A7C4F8C}&amp;quot;)
    if  err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(dibevnt_iid)

    // 이벤트 객체 생성 및 IUnkown, IDispatch 구현  콜백등록
    evnt:= (new (CpReceiveEvent))
    evnt.lpVtbl = (new (CpReceivedEvntVtbl))
    evnt.lpVtbl.pQueryInterface = syscall.NewCallback(QueryInterface)
    evnt.lpVtbl.pAddRef = syscall.NewCallback(AddRef)
    evnt.lpVtbl.pRelease = syscall.NewCallback(Release)
    evnt.lpVtbl.pGetTypeInfoCount = syscall.NewCallback(GetTypeInfoCount)
    evnt.lpVtbl.pGetTypeInfo = syscall.NewCallback(GetTypeInfo)
    evnt.lpVtbl.pGetIDsOfNames = syscall.NewCallback(GetIDsOfNames)
    evnt.lpVtbl.pInvoke = syscall.NewCallback(Invoke)
    evnt.host = cpstkmst

    // connectionpoint container
    unknown_con, err := cpstkmst.QueryInterface(ole.IID_IConnectionPointContainer)
    if err != nil {
        fmt.Println(err)
        return 
    }

    fmt.Println(unknown_con)

    // get point
    container := (*ole.IConnectionPointContainer)(unsafe.Pointer(unknown_con))
    var point *ole.IConnectionPoint
    err = container.FindConnectionPoint(dibevnt_iid, &amp;amp;point)
    if err != nil {
        return
    }
    fmt.Println(point)

    // Advise
    cookie, err := point.Advise((*ole.IUnknown)(unsafe.Pointer(evnt)))
    container.Release()
    if err != nil {
        point.Release()
        fmt.Println(err)
        return
    }
    fmt.Println(&amp;quot;cookies&amp;quot;)
    fmt.Println(cookie)     

    // call method

    r, err := oleutil.CallMethod(cpstkmst, &amp;quot;SetInputValue&amp;quot;,0, &amp;quot;A000270&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r)

    r, err = oleutil.CallMethod(cpstkmst, &amp;quot;Request&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return 
    }
    fmt.Println(r)

    fmt.Println(&amp;quot;request after&amp;quot;)

    // wating infinite  
    cnt := 0
    var m ole.Msg
    for evnt.ref != 0 {
        time.Sleep(10)
        ole.GetMessage(&amp;amp;m,0,0,0)
        ole.DispatchMessage(&amp;amp;m)
        if cnt &amp;gt; 1000 {
            break
        }
        cnt++
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기까지는 단지 연동만 해본것일 뿐이다. 이를 사용하기 쉽도록 묶고 라이브러리 처럼 만들려면 이를 응용하여 만들면 될 것이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rename file</title>
      <link>https://ippoeyeslhw.github.io/post/rename-file/</link>
      <pubDate>Tue, 24 Jan 2017 21:59:34 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/rename-file/</guid>
      <description>

&lt;p&gt;8년전 보았던 미드가 생각나서 구했는데 워낙 예전것이라 자막과 영상의 소스가 달라 일괄 변경할 필요가 생겼다. 그래서 go언어로 짜보았다.&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;flag&amp;quot;  
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
)


func getFileName( p string ) string {
    return p[0:len(p)-len(filepath.Ext(p))]
}

func main(){
    fmt.Println(&amp;quot;start renaming&amp;quot;)

    src_ext := flag.String(&amp;quot;src&amp;quot;, &amp;quot;.avi&amp;quot;, &amp;quot;source file-extension&amp;quot;)
    dst_ext := flag.String(&amp;quot;dst&amp;quot;, &amp;quot;.smi&amp;quot;, &amp;quot;destination file-extension&amp;quot;)

    flag.Parse()

    fmt.Println(*src_ext, *dst_ext)

    // 현재 디렉토리 파일 검색
    files, err := ioutil.ReadDir(&amp;quot;.&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;read dir fail&amp;quot;)
        os.Exit(1)
    }

    src_list := make([]string, 0)
    dst_list := make([]string, 0)

    for _, file := range files {
        if filepath.Ext(file.Name()) == *src_ext {
            src_list = append(src_list, file.Name())
        }
        if filepath.Ext(file.Name()) == *dst_ext {
            dst_list = append(dst_list, file.Name())
        }
    }

    if len(src_list) != len(dst_list) {
        fmt.Println(&amp;quot;diff num of files&amp;quot;, len(src_list), len(dst_list))
        os.Exit(1)
    }

    for i, nm := range src_list {
        fmt.Println(i, dst_list[i], &amp;quot;-&amp;gt;&amp;quot;, getFileName(nm) + filepath.Ext(dst_list[i]) )
        os.Rename(dst_list[i], getFileName(nm) + filepath.Ext(dst_list[i]))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flag&#34;&gt;flag&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/flag/&#34;&gt;flag&lt;/a&gt; 패키지는 커맨드라인에서 flag를 달아줄때 해당 값을 읽어올때 사용한다. 만일 -h 옵션을 주면 도움말을 알아서 만들어준다.&lt;/p&gt;

&lt;h2 id=&#34;path-filepath&#34;&gt;path/filepath&lt;/h2&gt;

&lt;p&gt;filepath를 파일 확장자를 발라내는데 사용했다. 다만 확장자를 뺸 나머지 이름을 가져오는 방법이 없어 slice 를 활용하여 아래처럼 사용했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return p[0:len(p)-len(filepath.Ext(p))]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;slice&#34;&gt;slice&lt;/h2&gt;

&lt;p&gt;목적확장자를 가진 파일과 대상 확장자를 가진 파일을 각각 slice에 담도록 했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src_list := make([]string, 0)
dst_list := make([]string, 0)

for _, file := range files {
    if filepath.Ext(file.Name()) == *src_ext {
        src_list = append(src_list, file.Name())
    }
    if filepath.Ext(file.Name()) == *dst_ext {
        dst_list = append(dst_list, file.Name())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rename&#34;&gt;rename&lt;/h2&gt;

&lt;p&gt;os.Rename을 사용하면 파일명을 바꿀수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, nm := range src_list {
    fmt.Println(i, dst_list[i], &amp;quot;-&amp;gt;&amp;quot;, getFileName(nm) + filepath.Ext(dst_list[i]) )
    os.Rename(dst_list[i], getFileName(nm) + filepath.Ext(dst_list[i]))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>hello hugo</title>
      <link>https://ippoeyeslhw.github.io/post/hello-hugo/</link>
      <pubDate>Tue, 24 Jan 2017 21:27:13 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/hello-hugo/</guid>
      <description>

&lt;p&gt;정적블로그를 하고 싶다는 생각이 들었다. 최근 Go언어를 하다보니 자연스럽게 &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;를 알게 되었고 정적 사이트를 생성하는데 편리하고 속도가 빠른것을 알게되었다. 그래서 이제 블로그를 정적블로그로 만들기로 했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;설치&#34;&gt;설치&lt;/h2&gt;

&lt;p&gt;설치는 &lt;a href=&#34;https://gohugo.io/overview/installing/&#34;&gt;Hugo installing&lt;/a&gt;을 참조하면 된다. 바이나리를 받아서 적당한 폴더에다가 넣어놓은뒤에 환경변수에 등록해주면 된다.&lt;/p&gt;

&lt;p&gt;나같은 경우는 윈도우 환경이므로 윈도우 바이너리를 받은후 폴더도 생성하였다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\hugo\bin\hugo.exe
C:\hugo\sites\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행파일은 bin 폴더에다가 넣고 sites 라는 폴더에다가는 정적웹페이지를 생성하도록 하려고 구성하였다.&lt;/p&gt;

&lt;h2 id=&#34;블로그구성하기&#34;&gt;블로그구성하기&lt;/h2&gt;

&lt;p&gt;Hugo의 &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;quickstart&lt;/a&gt; 문서를 보게되면 만들고자하는 사이트를 만드는 명령어가 나온다. 일단 sites 폴더로 이동한뒤에 아래 명령을 수행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러개의 폴더와 문서가 생성된것을 볼수 있다.&lt;/p&gt;

&lt;h2 id=&#34;테마추가하기&#34;&gt;테마추가하기&lt;/h2&gt;

&lt;p&gt;Hugo 사이트에서 &lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;Theme Showcase&lt;/a&gt;를 눌러보면 여러 테마가 나온다. 맘에드는 테마를 골라서 설치하면 된다. 나는 윈도우 기준으로 설치하고 있으므로 테마 파일을 받은뒤에&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\hugo\sites\blog\themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 폴더를 생상한뒤에 테마명으로 폴더를 생성하여 받은 파일을 풀어놓았다. 그뒤에 중요한 작업이 있는데&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\hugo\sites\blog\config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 파일에&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;theme = &amp;quot;theme-name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 내용이 추가가 되어야 한다.&lt;/p&gt;

&lt;p&gt;그리고 테마를 고르면 사용방법이 나오는데 위 config 파일에 테마 설정을 작성해 넣는식으로 사용한다. 이는 테마마다 사용법이 다르다.&lt;/p&gt;

&lt;h2 id=&#34;post-쓰기&#34;&gt;Post 쓰기&lt;/h2&gt;

&lt;p&gt;hugo에서는 Post를 쓸때 Markdown 파일을 작성하도록 한다. 이글도 Markdown으로 쓰고 있다. &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;quickstart&lt;/a&gt; 문서를 보면 Step3에 포스트를 작성하는 법이 나온다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hugo new post/first-post.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령을 수행하고 나면 post라는 폴더와 위 이름의 .md 파일이 생성되어 있음을 확인할수 있다.&lt;/p&gt;

&lt;h2 id=&#34;정적페이지-생성&#34;&gt;정적페이지 생성&lt;/h2&gt;

&lt;p&gt;md파일을 작성할때 Draft는 초고를 의미하므로 기본적으로 true로 되어있다. 이를 False로 바꾼뒤에 blog 폴더하에서&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;단순하게 위 명령만 치면 자동으로 페이지를 생성하여&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\hugo\sites\blog\public 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 폴더에 각종파일들이 생성된다. 이것들이 정적페이지들이다. 이를 호스팅하는 곳에 올리면 된다. 개인적으로는 github의 gh-pages 브랜치를 사용하고 있다.&lt;/p&gt;

&lt;h2 id=&#34;로컬에서-확인&#34;&gt;로컬에서 확인&lt;/h2&gt;

&lt;p&gt;로컬에서 잠시 웹서버를 올려서 어떻게 보이는지 확인할수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;blog 폴더 안에서 위 명령을 실행하면 웹서버가 뜬다. localhost:1313/blog 이런식으로 접근하면 된다.&lt;/p&gt;

&lt;p&gt;Draft 버젼 또한 보고싶은 경우가 있다. 이때는 -D 옵션을 준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo -D server
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;어찌보면 이렇게 블로그를 생성하는것은 불편하기도 한다. 명령어를 쳐서 파일을 만들고 폴더를 만든뒤에 집어넣어야 되고 생성을 시킨뒤에 그걸 또 호스팅 서버에 올려야 하기도 한다. 하지만 이렇게 만들어 놓으면 뭔가 명확하고 확실한 느낌이 난다. DB와도 상관이 없고 서버에 부담없이 깔끔하다. 다양한 기능이 필요가 없기에 이런 정적페이지 생성기가 유용해보인다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>