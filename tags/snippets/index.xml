<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Snippets on lhw_itguy</title>
    <link>https://ippoeyeslhw.github.io/tags/snippets/</link>
    <description>Recent content in Snippets on lhw_itguy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 28 Aug 2017 21:15:49 +0900</lastBuildDate>
    
	<atom:link href="https://ippoeyeslhw.github.io/tags/snippets/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Py Datetime Stamp</title>
      <link>https://ippoeyeslhw.github.io/post/py-datetime-stamp/</link>
      <pubDate>Mon, 28 Aug 2017 21:15:49 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/py-datetime-stamp/</guid>
      <description>파이썬에서 Datetime 을 이용하여 unix timestamp 를 구하고 싶을 경우가 있다. 1970-1-1 을 기준으로 차이값(time delta)를 구한뒤에 총 초를 구하고 밀리세컨 단위로 바꿔주면 된다.
import datetime def unix_timestamp(y,m,d,h): dt = datetime.datetime(y,m,d,h) epoch = datetime.datetime(1970,1,1) return int((dt-epoch).total_seconds() * 1000) stmp = unix_timestamp(2017,8,28,13) print (stmp)  이렇게 구하면 날짜 지정하기가 쉬워진다.</description>
    </item>
    
    <item>
      <title>Decorator Elapsed Time</title>
      <link>https://ippoeyeslhw.github.io/post/decorator-elapsed-time/</link>
      <pubDate>Thu, 24 Aug 2017 20:57:17 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/decorator-elapsed-time/</guid>
      <description>파이썬의 데코레이터를 이용하여 Elapsed time 을 측정하는 간단한 예제는 데코레이터를 설명하는데 자주 쓰인다.
def print_elapsed(func): def wrapper(*args, **kwargs): start = time.time() print (&#39;--- start time check (%s)-----&#39;%(func.__name__)) func(*args, **kwargs) elased = time.time() - start print(&#39;--- end time check Elapsed: %s&#39;%(elased)) print(&#39; &#39;) return wrapper  인자를 넘겨주는 부분이 약간 헷갈릴수 있는데 데코레이터 자체는 함수를 인자로 받아 함수를 리턴해주는 것이고
실제 그 함수를 사용할때는 리턴받은 함수에 인자를 넘겨주는 셈이 된다고 이해하면 된다.</description>
    </item>
    
    <item>
      <title>Go Http Request</title>
      <link>https://ippoeyeslhw.github.io/post/go-http-request/</link>
      <pubDate>Tue, 22 Aug 2017 20:32:12 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/go-http-request/</guid>
      <description>고언어에서 HTTP request하는 법을 포스팅한다.
package main import ( &amp;quot;bytes&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;net/url&amp;quot; ) func main() { // data uri := &amp;amp;url.Values{} uri.Add(&amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;) // request req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://www.naver.com&amp;quot;, bytes.NewBufferString(uri.Encode())) if err != nil { panic(err) } // set header req.Header.Add(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.78 Safari/537.36&amp;quot;) // request client := &amp;amp;http.Client{} resp, err := client.Do(req) if err != nil { panic(err) } // read response data, err := ioutil.</description>
    </item>
    
    <item>
      <title>Py3 Http Request</title>
      <link>https://ippoeyeslhw.github.io/post/py3-http-request/</link>
      <pubDate>Tue, 22 Aug 2017 19:43:41 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/py3-http-request/</guid>
      <description>파이썬3 에서 써드파티 라이브러리 없이 Http Request 하는 법을 포스팅한다.
GET 요청 기본 import urllib.request url = &#39;http://www.naver.com&#39; f = urllib.request.urlopen(url) print (f.read().decode(&#39;utf-8&#39;))  가장 간단하게 urlopen 메소드를 사용하는 방법이다. f는 class &amp;lsquo;http.client.HTTPResponse&amp;rsquo; 이며 f.read() 메소드는 bytes 오브젝트를 반환하며 이를 디코딩해서 str로 사용한다.
GET 요청 + HEADER import urllib.request url = &#39;http://www.naver.com&#39; REQ_HEADERS = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.78 Safari/537.36&#39;, } req = urllib.</description>
    </item>
    
    <item>
      <title>Go Signal</title>
      <link>https://ippoeyeslhw.github.io/post/go-signal/</link>
      <pubDate>Tue, 22 Aug 2017 01:01:33 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/go-signal/</guid>
      <description>고언어에서 os signal 을 콘트롤 하는 방법을 찾아보았다.
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;os&amp;quot; &amp;quot;os/signal&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func main() { // signal 채널을 만든다. signal_chan := make(chan os.Signal, 2) signal.Notify(signal_chan, syscall.SIGINT) // ctrl+c // loop isDone := false for isDone != true { // signal handler select { case sig := &amp;lt;-signal_chan: fmt.Println(&amp;quot;signal!! &amp;quot;, sig) isDone = true default: isDone = false } time.Sleep(1) } }  채널을 통해서 signal을 전달하게 된다.</description>
    </item>
    
    <item>
      <title>Thread Pool</title>
      <link>https://ippoeyeslhw.github.io/post/thread-pool/</link>
      <pubDate>Tue, 22 Aug 2017 00:30:30 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/thread-pool/</guid>
      <description>파이썬에서 스레드풀 검색해본 결과 간단하게 구현할수 있는 방법을 구글링을 통해 찾았다. 워커 스레드는 클래스로 상속하고 run 메소드를 오버라이드 한다.
daemon 프로퍼티는 daemon 스레드로 작업할 것을 명시하는것으로써 기본은 False이며 메인스레드가 종료되어도 끝까지 자기의 작업을 수행하며 True일 경우 메인스레드가 종료될시 같이 종료된다.
작업스레드에서 작업종료시 task_done을 호출한다. 이때 메인스레드에서 queue.join 메소드를 이용하여 블락된채로 모든작업이 끝날 때 까지 대기할수 있다.
from queue import Queue from threading import Thread class Worker(Thread): def __init__(self, tasks, results): Thread.</description>
    </item>
    
    <item>
      <title>Rename File</title>
      <link>https://ippoeyeslhw.github.io/post/rename-file/</link>
      <pubDate>Tue, 22 Aug 2017 00:12:44 +0900</pubDate>
      
      <guid>https://ippoeyeslhw.github.io/post/rename-file/</guid>
      <description>8년전 보았던 미드가 생각나서 구했는데 워낙 예전것이라 자막과 영상의 소스가 달라 일괄 변경할 필요가 생겼다. 그래서 go언어로 짜보았다.
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;flag&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;os&amp;quot; &amp;quot;path/filepath&amp;quot; ) func getFileName( p string ) string { return p[0:len(p)-len(filepath.Ext(p))] } func main(){ fmt.Println(&amp;quot;start renaming&amp;quot;) src_ext := flag.String(&amp;quot;src&amp;quot;, &amp;quot;.avi&amp;quot;, &amp;quot;source file-extension&amp;quot;) dst_ext := flag.String(&amp;quot;dst&amp;quot;, &amp;quot;.smi&amp;quot;, &amp;quot;destination file-extension&amp;quot;) flag.Parse() fmt.Println(*src_ext, *dst_ext) // 현재 디렉토리 파일 검색 files, err := ioutil.ReadDir(&amp;quot;.&amp;quot;) if err != nil { fmt.</description>
    </item>
    
  </channel>
</rss>