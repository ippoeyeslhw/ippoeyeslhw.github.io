<!DOCTYPE html>
<html lang="ko">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.15" />

  <title>mandelbrot fractal golang &middot; ItGae Blog</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://ippoeyeslhw.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://ippoeyeslhw.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://ippoeyeslhw.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/monokai-sublime.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://ippoeyeslhw.github.io/img/favicon.ico" type="image/x-icon" />

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://ippoeyeslhw.github.io/">ItGae</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ippoeyeslhw.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://ippoeyeslhw.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://instagram.com/leehyunwoo_itguy" target="_blank"><i class="fa fa-instagram fa-fw"></i>Instagram</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/ippoeyeslhw" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>mandelbrot fractal golang</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>28 May 2016, 16:56</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://ippoeyeslhw.github.io/topics/golang">golang</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://ippoeyeslhw.github.io/tags/golang">golang</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://ippoeyeslhw.github.io/tags/mandelbrot">mandelbrot</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://ippoeyeslhw.github.io/tags/fractal">fractal</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://ippoeyeslhw.github.io/tags/image">image</a>
    
  </div>
  
  

</div>

  

<p>go언어의 <a href="https://golang.org/pkg/">package</a>문서를 보다보니
<a href="https://golang.org/pkg/image/">image</a>패키지를 보게 되었다.
go언어 익숙해질겸 기존에 몇번 작성해보았던 Mandelbrot Fractal
을 만들어 보기로 마음 먹었다.</p>

<p><a href="https://ippoeyeslhw.github.io/static/img/mandelbrot_fractal_1.png"><img src="https://ippoeyeslhw.github.io/static/img/mandelbrot_fractal_1_600_400.png" alt="mandelbrot fractal" /></a></p>

<h2 id="픽셀-콘트롤:1d83e155d6be62d461d335add2587317">픽셀 콘트롤</h2>

<p>표준라이브러리의 <a href="https://golang.org/pkg/image/">image</a>패키지를
찾아보다보니 픽셀을 Set하는 것처럼 보이는 부분이 있었다.</p>

<pre><code>func (p *RGBA) Set(x, y int, c color.Color)
</code></pre>

<p>RGBA 구조체에 특정 x,y좌표의 픽셀에 Color를 지정하는것으로 보인다.</p>

<p>그렇다면 몇가지 의문이 생긴다.</p>

<ul>
<li>Jpeg, Png 같은 이미지로 저장을 할수 있는지</li>
<li>Color는 무엇인지</li>
</ul>

<h2 id="이미지-생성-및-저장:1d83e155d6be62d461d335add2587317">이미지 생성 및 저장</h2>

<p>간단하게 이미지를 생성 및 저장해보기로 한다.
png 포맷으로 저장하는 방법을 찾아보다가 보니
image 패키지의 서브디렉토리에 Png가 있었다.</p>

<p><a href="https://golang.org/pkg/image/png/">png패키지</a></p>

<p>여기서 Encode함수 정의를 보면</p>

<pre><code>func Encode(w io.Writer, m image.Image) error
</code></pre>

<p>첫번쨰 인자가 io.Writer 인것을 볼수 있다.
이를 파일로 지정하면 얼추 되지 않을까?</p>

<p>저 Writer 를 클릭해보면</p>

<pre><code>type Writer interface {
        Write(p []byte) (n int, err error)
}
</code></pre>

<p>Write 인터페이스가 구현되는 구조체? 이면 저 Encode 함수 인자로 넘길수
있는것 같아보인다.
그리고 <a href="https://golang.org/pkg/os#File.Write">os패키지</a>
에  File구조체의 Write 함수를 보자</p>

<pre><code>func (f *File) Write(b []byte) (n int, err error)
</code></pre>

<p>그냥 저렇게 함수를 구현하면 위 인터페이스가 구현이 되는것인지
의문이 든다. Java 같은 언어처럼 인터페이스를 상속하도록 지정할 필요가 없는것인지
이는 실제로 코드를 짜서 확인해보도록 한다.</p>

<pre><code>package main

import(
    &quot;fmt&quot;
    &quot;image&quot;
    &quot;image/png&quot;
    &quot;os&quot;
)

func main(){

    fmt.Println(&quot;step 1&quot;)

    // 이미지생성
    img := image.NewRGBA(image.Rect(0,0,300,200))

    // 파일생성 및 open
    f, f_err := os.Create(&quot;test.png&quot;)
    if f_err != nil {
        os.Exit(1)
    }

    png_err := png.Encode(f, img)
    if png_err != nil {
        os.Exit(1)
    }

    // 파일 닫기
    f.Close()
}
</code></pre>

<p>테스트용으로 짠코드이다. 이를 수행하면 뭔가 파일이 생성됨을 알수 있다.
결국 File 구조체는 Write 함수를 Writer 인터페이스 형식에 맞게 구현했기 때문에 인터페이스가 구현되었고 png.Encode의 첫번쨰 인자로 집어넣을수 있다.</p>

<p>생성된 png파일은 열어보면 아무것도 보이지 않는다.
실제로 맞게 생성이 된것인지 확인 및
img.Set 함수가 제대로 동작을 하는건지 확인하기 위해
직선을 그어서 확인해보도록 한다.</p>

<pre><code>// 이미지생성
img := image.NewRGBA(image.Rect(0,0,300,200))

// test draw
for i := 0; i &lt; 100; i++ {
    img.Set(50 + i, 100, color.RGBA{255,0,0,255})
}
//... 코드생략
</code></pre>

<p><img src="https://ippoeyeslhw.github.io/static/img/test_line.png" alt="test line" /></p>

<p>빨간선이 그어졌다!</p>

<p>RGBA 임을 생각해보면 A = Alpha 값임을 생각해보면 된다.
즉 그냥 이미지를 생성하면 투명한상태의 이미지파일이 생성되는 것이다.</p>

<p>여기서 color는 <a href="https://golang.org/pkg/image/color/">image/color 패키지</a>
의 인터페이스이다.</p>

<pre><code>type Color interface {
        // RGBA returns the alpha-premultiplied red, green, blue and alpha values
        // for the color. Each value ranges within [0, 0xffff], but is represented
        // by a uint32 so that multiplying by a blend factor up to 0xffff will not
        // overflow.
        //
        // An alpha-premultiplied color component c has been scaled by alpha (a),
        // so has valid values 0 &lt;= c &lt;= a.
        RGBA() (r, g, b, a uint32)
}
</code></pre>

<p>위의 Writer와 비슷하게 RGBA 함수가 구현된 type이면 인자로 넘길수 있는것이다.</p>

<p>다른 표준라이브러리들도 이와 유사한 방식으로 이해하면 될것 같은 느낌이 든다.</p>

<h2 id="에러-처리:1d83e155d6be62d461d335add2587317">에러 처리</h2>

<p>os.Create 함수를 사용할때 보면 f_err 를 리턴받아 에러여부를 확인했다.
go언어는 try-catch 매커니즘이 없는듯 하다.
커스텀 에러처리를 할때는 어떻게 할지 궁금해서 찾아보니
역시나 인터페이스이다&hellip; <a href="https://golang.org/pkg/builtin/#error">error정의</a></p>

<pre><code>type error interface {
        Error() string
}
</code></pre>

<p>그렇다면 내가 커스텀에러 타입을 정의한뒤에 Error() 를 구현하여
error 를 리턴하게 하면 되는것이다.</p>

<pre><code>// simple error handling
type errorString struct {
    at string
    msg string
}
func (e *errorString) Error() string {
    return fmt.Sprintf(&quot;at %s : %s Error&quot;, e.at, e.msg)
}

func errTest () error {
    return &amp;errorString {&quot;at&quot;, &quot;errTest&quot;}
}
</code></pre>

<p>위와같이 정의하면 내가 정의한 errorString 이라는 타입은 Error 함수를 구현하였다.
그래서 errTest()함수의 리턴타입은 error 인터페이스를 구현하였으니
리턴할때 해당타입을 사용할수 있다.</p>

<pre><code>err := errTest()
if err != nil {
    fmt.Println(err)
}
</code></pre>

<h2 id="이미지초기화:1d83e155d6be62d461d335add2587317">이미지초기화</h2>

<p>이미지를 생성할때 위와같이 하면 투명하게 되어
검정색이든 하얀색이든 기본색으로 클리어해주는 방식을
찾아볼 필요가 생겼다.</p>

<p>package를 뒤져보고 구글링을 해보니
<a href="https://golang.org/pkg/image/draw/">image/draw 패키지</a>
Draw 함수와
image.Uniform 타입을 활용하면 되는것 같다.</p>

<pre><code>draw.Draw(img, img.Bounds(), &amp;image.Uniform{c}, image.ZP, draw.Src )
</code></pre>

<p>Uniform의 c 값은 Color이다.</p>

<h2 id="기본골격-정의:1d83e155d6be62d461d335add2587317">기본골격 정의</h2>

<p>위와 같이 에러 처리및 파일 저장, 이미지 초기화와 같은 것들을 이용하여
골격을 정의하여 이미지 파일을 생성하도록 한다.</p>

<pre><code>// 파일저장함수
func saveImg(img *image.RGBA, fname string) error {
    f, fe := os.Create(fname)
    if fe != nil {
        return &amp;errorString{&quot;saveImg&quot;, &quot;file Create&quot;}
    }

    pe := png.Encode(f, img)
    if pe != nil {
        return &amp;errorString{&quot;saveImg&quot;, &quot;png Encode&quot;}    
    }

    f.Close()
    return nil
}
</code></pre>

<p>이미지와 파일이름을 받아 저장할수 있도록 함수를 정의하고
아까 정의한 커스텀 에러 처리를 응용한다.</p>

<pre><code>func main(){

    // 기본 이미지 사용 
    img := image.NewRGBA(image.Rect(0,0,600,400))

    // 초기화 (black)
    draw.Draw(img, img.Bounds(), &amp;image.Uniform{&amp;color.RGBA{0,0,0,255}}, image.ZP, draw.Src)

    // 그리기


    // 파일저장
    save_err := saveImg(img, &quot;out.png&quot;)
    if save_err != nil {
        fmt.Println(save_err)
        os.Exit(1)
    }

}
</code></pre>

<p>일단 위의 소스를 돌려보면 검정색의 그림파일이 생성된다.</p>

<h2 id="첫번째-프랙탈:1d83e155d6be62d461d335add2587317">첫번째 프랙탈</h2>

<p>이제 png 파일이 생성되며 중간에 픽셀값을 찍어서 그림파일을 생성할수
있다.
<a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot Fractal</a>
복소평면에서 Zn+1 = Zn^2 + c 에서 얼마나 빨리 발산하는지에 따른 c값의 집합이다.</p>

<p>흔히 프랙탈 이미지는 점화식을 반복에 의해 진행시켜나가면서
대부분 256단계에 발산을 하는지 보고 256 이하 값을 선택하여 밝기
및 색상을 선택한다.</p>

<p>프랙탈의 범위는 실수부 -2 ~ 1, 허수부 -1 ~ 1 사이값이다.
이미지를 생성하기 위해서는 모든 각각의 픽셀위치의 좌표를 구한뒤
얼마나 빨리 발산하는지 판별하여 그 값을 색상으로 지정하면 된다.</p>

<p>프랙탈은 나중에 줌인, 줌아웃의 기능을 위해 뷰 범위를 지정할 필요가 있다.</p>

<pre><code>type FractalRect struct {
    X, Y ,W, H float64
}
</code></pre>

<p>발산단계를 구하기 위해 아래와 같은 함수를 선언한다.</p>

<pre><code>func getLevel(rect *FractalRect, p *image.Point, w, h int) int {
    var cX float64 = rect.X + float64(p.X) * (rect.W / float64(w))
    var cY float64 = rect.Y + float64(p.Y) * (rect.H / float64(h))
    X := cX
    Y := cY

    cnt := 256
    for i:=0; i &lt; 256; i++ {
        X2 := X * X
        Y2 := Y * Y
        if X2 + Y2 &gt; 4.0 {
            cnt = i
            break
        }
        nX := X2 - Y2 + cX
        nY := 2 * X * Y + cY
        X = nX
        Y = nY
    }
    return cnt
}
</code></pre>

<p>보고자 하는 좌표를 지정한뒤
이미지의 좌표 Point 및 이미지의 Width, Height 를 구한다.
결국 이미지의 어떤 픽셀의 위치에 해당되는 실수 좌표를 구한뒤에
이를 기반으로 256 단계 이내에 얼마나 빨리 발산하는지 확인하는 것이다.</p>

<p>모든 픽셀에 대해서 위 함수를 적용하여 밝기를 지정하도록
그리기 함수를 선언한다.</p>

<pre><code>func drawFractal(rect *FractalRect, img *image.RGBA) {
    width := img.Bounds().Max.X
    height := img.Bounds().Max.Y

    for i:=0; i &lt; height; i++ {
        for j:=0; j &lt; width; j++{
            level := uint8(getLevel(rect, &amp;image.Point{j,i}, width, height))
            img.Set(j, i, &amp;color.RGBA{level,level,level,255})
        }
    }
} 
</code></pre>

<p>그러면 아까 만들어 뒀던 골격에 적용하면</p>

<pre><code>func main(){

    fmt.Println(&quot;step 1&quot;)

    // 기본 이미지 사용 
    img := image.NewRGBA(image.Rect(0,0,600,400))

    // 초기화 (black)
    draw.Draw(img, img.Bounds(), &amp;image.Uniform{&amp;color.RGBA{0,0,0,255}}, image.ZP, draw.Src)

    // 그리기
    drawFractal(&amp;FractalRect{-2,-1,3,2}, img)

    // 파일저장
    save_err := saveImg(img, &quot;out.png&quot;)
    if save_err != nil {
        fmt.Println(save_err)
        os.Exit(1)
    }

}
</code></pre>

<p>그러면 아래와 같은 첫번쨰 프랙탈 이미지가 나온다.</p>

<p><img src="https://ippoeyeslhw.github.io/static/img/fractal_1.png" alt="first fractal" /></p>

<h2 id="색상입히기:1d83e155d6be62d461d335add2587317">색상입히기</h2>

<p>프랙탈을 좀더 보기좋게 만들기 위해서 색상을 입히기로 한다.
색상을 칠하는 방법은 여러가지가 있지만
팔레트를 만들어서 레벨에 따라 선택하도록 만들것이다.</p>

<p>4가지의 색상을 지정한뒤 이를 256단계에 걸쳐서 변화하도록
보간하는 color 함수를 정의한다.</p>

<pre><code>func getColor(level int) color.RGBA {
    var color1, color2 color.RGBA
    // 256 -&gt; 128
    pos := math.Mod(float64(level), 128.0) / 128.0

    if level &gt;= 256 {
        return color.RGBA{0,0,0,255}
    }

    switch {
        case pos &lt; 0.25:
            color1 = color.RGBA{0,0,100,0}
            color2 = color.RGBA{255,255,255,25}
        case pos &lt; 0.5:
            color1 = color.RGBA{255,255,255,25}
            color2 = color.RGBA{255,128,0,50}
        case pos &lt; 0.75:
            color1 = color.RGBA{255,128,0,50}
            color2 = color.RGBA{0,0,0,75}
        case pos &lt; 1.0:
            color1 = color.RGBA{0,0,0,75}
            color2 = color.RGBA{0,0,100,100}
    }
    // alpha 값을 t위치 산정을 위해 사용
    t := 1.0 * (pos - float64(color1.A)/100.0) / (float64(color2.A)/100.0 - float64(color1.A)/100.0)

    r := uint8((1.0 - t) * float64(color1.R) + t * float64(color2.R))
    g := uint8((1.0 - t) * float64(color1.G) + t * float64(color2.G))
    b := uint8((1.0 - t) * float64(color1.B) + t * float64(color2.B))

    return color.RGBA{r,g,b,255}
}
</code></pre>

<p>이를 사용하여 팔레트를 생성하고 픽셀을 찍을경우
팔레트를 사용하도록 그리기 함수를 변경한다.</p>

<pre><code>func drawFractal(rect *FractalRect, img *image.RGBA) {

    // 팔레트 생성
    palette := make([]color.RGBA, 257) // 256 단계 넘어가는 경우

    for i:=0; i &lt; len(palette); i++ {
        palette[i] = getColor(i)
    }

    // 모든 픽셀 순회
    width := img.Bounds().Max.X
    height := img.Bounds().Max.Y

    for i:=0; i &lt; height; i++ {
        for j:=0; j &lt; width; j++{
            level := getLevel(rect, &amp;image.Point{j,i}, width, height)
            img.Set(j, i, &amp;palette[level])
        }
    }
}
</code></pre>

<p><a href="https://ippoeyeslhw.github.io/static/img/fractal_2.png"><img src="https://ippoeyeslhw.github.io/static/img/fractal_2_600_400.png" alt="color fractal" /></a></p>

<h2 id="계산현상-없애기:1d83e155d6be62d461d335add2587317">계산현상 없애기</h2>

<p>smooth coloring 과 관련한 부분이다.</p>

<pre><code>func getLevel(rect *FractalRect, p *image.Point, w, h int) (int, float64) {
    var cX float64 = rect.X + float64(p.X) * (rect.W / float64(w))
    var cY float64 = rect.Y + float64(p.Y) * (rect.H / float64(h))
    X := cX
    Y := cY

    cnt := 256
    for i:=0; i &lt; 256; i++ {
        X2 := X * X
        Y2 := Y * Y
        if X2 + Y2 &gt; 4.0 {
            cnt = i
            break
        }
        nX := X2 - Y2 + cX
        nY := 2 * X * Y + cY
        X = nX
        Y = nY
    }
    // t 값을 리턴하도록 수정함
    zn := math.Sqrt(X*X + Y*Y)
    nu := math.Log(math.Log(zn) / math.Log(2.0)) / math.Log(2.0)
    t := 1.0 - nu
    return cnt, t
}
</code></pre>

<p>해당 t값을 가지고 팔레트를 구할때처럼
보간하여 색상을 지정한다.</p>

<pre><code>func drawFractal(rect *FractalRect, img *image.RGBA) {

    // 팔레트 생성
    palette := make([]color.RGBA, 258) // 256 단계 넘어가는 경우

    for i:=0; i &lt; len(palette); i++ {
        palette[i] = getColor(i)
    }

    // 모든 픽셀 순회
    width := img.Bounds().Max.X
    height := img.Bounds().Max.Y

    for i:=0; i &lt; height; i++ {
        for j:=0; j &lt; width; j++{
            level,t := getLevel(rect, &amp;image.Point{j,i}, width, height)
            color1 := &amp;palette[level]
            color2 := &amp;palette[level+1]
            r := uint8((1.0 - t) * float64(color1.R) + t * float64(color2.R))
            g := uint8((1.0 - t) * float64(color1.G) + t * float64(color2.G))
            b := uint8((1.0 - t) * float64(color1.B) + t * float64(color2.B))

            img.Set(j, i, &amp;color.RGBA{r,g,b,255})
        }
    }
}
</code></pre>

<p>level+1 처리를 위해 팔레트 크기를 하나 더 늘렸다.
모든것을 적용한 최종 결과는 다음과 같다.</p>

<p><a href="https://ippoeyeslhw.github.io/static/img/fractal_3.png"><img src="https://ippoeyeslhw.github.io/static/img/fractal_3_600_400.png" alt="smooth color fractal" /></a></p>

<h2 id="후기:1d83e155d6be62d461d335add2587317">후기</h2>

<p>프랙탈의 위력은 줌인에 있다. 지금은 좌표가 -2~1, -1~1 사이의
모양을 그렸지만 실은 부분부분을 계속적으로 확대해 나갈때
프랙탈의 다채로운 모양이 나온다.</p>

<p><a href="https://ippoeyeslhw.github.io/static/img/zoom_fractal.png"><img src="https://ippoeyeslhw.github.io/static/img/zoom_fractal_600_400.png" alt="zoom fractal" /></a></p>

<p>image패키지와 웹서버를 구현하여 확대할 좌표를 구하고
이를 보여주는 식으로 계속 확대해 나가는 것을 구현해봐도 괜찮을 것이다.</p>

<p>go언어는 goroutine을 사용하여 thread 사용하기 쉽다고 한다.
CPU 지정하고 이를 활용하여 병렬 처리를 해도 괜찮을 것이다.</p>

<p>이 프로그램을 짜보면서 go언어의 표준라이브러리들의
인자를 넘기는 방법에 대한 힌트를 얻었다.
인터페이스를 지정하면 이를 구현하는 타입은 어떤 타입이든지
산관없이 넘길수 있어 커스텀 타입을 구현하여 넘길수 있는것을
가능하게 해주는것 같다.</p>

<p>이 글을 쓰면서 작성한 프로그램 소스를 아래에 제시하며 마친다.</p>

<pre><code>package main

import(
    &quot;fmt&quot;
    &quot;image&quot;
    &quot;image/png&quot;
    &quot;image/color&quot;
    &quot;image/draw&quot;
    &quot;math&quot;
    &quot;os&quot;
)

// simple error handling
type errorString struct {
    at string
    msg string
}
func (e *errorString) Error() string {
    return fmt.Sprintf(&quot;at %s : %s Error&quot;, e.at, e.msg)
}

type FractalRect struct {
    X, Y ,W, H float64
}

func getLevel(rect *FractalRect, p *image.Point, w, h int) (int, float64) {
    var cX float64 = rect.X + float64(p.X) * (rect.W / float64(w))
    var cY float64 = rect.Y + float64(p.Y) * (rect.H / float64(h))
    X := cX
    Y := cY

    cnt := 256
    for i:=0; i &lt; 256; i++ {
        X2 := X * X
        Y2 := Y * Y
        if X2 + Y2 &gt; 4.0 {
            cnt = i
            break
        }
        nX := X2 - Y2 + cX
        nY := 2 * X * Y + cY
        X = nX
        Y = nY
    }
    zn := math.Sqrt(X*X + Y*Y)
    nu := math.Log(math.Log(zn) / math.Log(2.0)) / math.Log(2.0)
    t := 1.0 - nu
    return cnt, t
}


// 파일저장함수
func saveImg(img *image.RGBA, fname string) error {
    f, fe := os.Create(fname)
    if fe != nil {
        return &amp;errorString{&quot;saveImg&quot;, &quot;file Create&quot;}
    }

    pe := png.Encode(f, img)
    if pe != nil {
        return &amp;errorString{&quot;saveImg&quot;, &quot;png Encode&quot;}    
    }

    f.Close()
    return nil
}
func getColor(level int) color.RGBA {
    var color1, color2 color.RGBA
    // 256 -&gt; 128
    pos := math.Mod(float64(level), 128.0) / 128.0

    if level &gt;= 256 {
        return color.RGBA{0,0,0,255}
    }

    switch {
        case pos &lt; 0.25:
            color1 = color.RGBA{0,0,100,0}
            color2 = color.RGBA{255,255,255,25}
        case pos &lt; 0.5:
            color1 = color.RGBA{255,255,255,25}
            color2 = color.RGBA{255,128,0,50}
        case pos &lt; 0.75:
            color1 = color.RGBA{255,128,0,50}
            color2 = color.RGBA{0,0,0,75}
        case pos &lt; 1.0:
            color1 = color.RGBA{0,0,0,75}
            color2 = color.RGBA{0,0,100,100}
    }
    // alpha 값을 t위치 산정을 위해 사용
    t := 1.0 * (pos - float64(color1.A)/100.0) / (float64(color2.A)/100.0 - float64(color1.A)/100.0)

    r := uint8((1.0 - t) * float64(color1.R) + t * float64(color2.R))
    g := uint8((1.0 - t) * float64(color1.G) + t * float64(color2.G))
    b := uint8((1.0 - t) * float64(color1.B) + t * float64(color2.B))

    return color.RGBA{r,g,b,255}
}

func drawFractal(rect *FractalRect, img *image.RGBA) {

    // 팔레트 생성
    palette := make([]color.RGBA, 258) // 256 단계 넘어가는 경우

    for i:=0; i &lt; len(palette); i++ {
        palette[i] = getColor(i)
    }

    // 모든 픽셀 순회
    width := img.Bounds().Max.X
    height := img.Bounds().Max.Y

    for i:=0; i &lt; height; i++ {
        for j:=0; j &lt; width; j++{
            level,t := getLevel(rect, &amp;image.Point{j,i}, width, height)
            color1 := &amp;palette[level]
            color2 := &amp;palette[level+1]
            r := uint8((1.0 - t) * float64(color1.R) + t * float64(color2.R))
            g := uint8((1.0 - t) * float64(color1.G) + t * float64(color2.G))
            b := uint8((1.0 - t) * float64(color1.B) + t * float64(color2.B))

            img.Set(j, i, &amp;color.RGBA{r,g,b,255})
        }
    }
}

func main(){

    fmt.Println(&quot;step 1&quot;)

    // 기본 이미지 사용 
    img := image.NewRGBA(image.Rect(0,0,3000,2000))

    // 초기화 (black)
    draw.Draw(img, img.Bounds(), &amp;image.Uniform{&amp;color.RGBA{0,0,0,255}}, image.ZP, draw.Src)

    // 그리기
    drawFractal(&amp;FractalRect{-2,-1,3,2}, img)
    //drawFractal(&amp;FractalRect{-1.4,-0.4,0.6,0.4}, img)

    // 파일저장
    save_err := saveImg(img, &quot;out.png&quot;)
    if save_err != nil {
        fmt.Println(save_err)
        os.Exit(1)
    }

}
</code></pre>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://ippoeyeslhw.github.io/post/hello-hugo/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://ippoeyeslhw.github.io/post/hello-hugo/">hello hugo</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="https://ippoeyeslhw.github.io/post/rename-file/">rename file</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="https://ippoeyeslhw.github.io/post/rename-file/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  

</div>

</div>
</div>
<script src="https://ippoeyeslhw.github.io/js/ui.js"></script>




</body>
</html>

